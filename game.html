<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Glide Warrior</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body { 
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', monospace;
        }
        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border: 2px solid #0a0;
        }
    </style>
</head>
<body>
    <script>
        // Get parameters from URL
        const urlParams = new URLSearchParams(window.location.search);
        const PLAYER_NAME = urlParams.get('player') || 'WARRIOR';
        const CHARACTER_TYPE = urlParams.get('char') || 'soldier';
        const DIFFICULTY = urlParams.get('diff') || 'normal';
        const START_LEVEL = parseInt(urlParams.get('level')) || 1;
        const COOP_MODE = urlParams.get('coop') === 'true';
        const PLAYER2_NAME = urlParams.get('player2') || 'SIDEKICK';
        
        // Character stats
        const characterStats = {
            soldier: { speed: 4, jumpPower: 12, health: 3, special: 'balanced', spriteIndex: 0 },
            speedster: { speed: 6, jumpPower: 15, health: 2, special: 'doubleJump', spriteIndex: 1 },
            tank: { speed: 3, jumpPower: 10, health: 5, special: 'armor', spriteIndex: 2 },
            ninja: { speed: 5, jumpPower: 13, health: 2, special: 'dash', spriteIndex: 3 }
        };
        
        // Difficulty settings
        const difficultySettings = {
            easy: { enemySpeed: 1, enemyHealth: 2, enemyCount: 3, spawnRate: 300 },
            normal: { enemySpeed: 1.5, enemyHealth: 3, enemyCount: 5, spawnRate: 240 },
            hard: { enemySpeed: 2, enemyHealth: 4, enemyCount: 7, spawnRate: 180 }
        };
        
        const settings = difficultySettings[DIFFICULTY] || difficultySettings.normal;
        const charStats = characterStats[CHARACTER_TYPE] || characterStats.soldier;
        
        // --- NEW: Image Assets ---
        let assets = {};

        function preload() {
            // These URLs point to the new, high-def game assets.
            assets.playerSheet = loadImage('https://i.ibb.co/tYH81H1/player-sprites.png');
            assets.enemySheet = loadImage('https://i.ibb.co/p1YtFhp/enemy-sprites.png');
            assets.tileSet = loadImage('https://i.ibb.co/FqsYq5j/tileset.png');
            assets.background1 = loadImage('https://i.ibb.co/s5bs0kM/bg-layer-1.png');
            assets.background2 = loadImage('https://i.ibb.co/3cY0j1p/bg-layer-2.png');
            assets.effects = loadImage('https://i.ibb.co/wJMy7s9/effects.png');
            assets.powerups = loadImage('https://i.ibb.co/bB5xqc1/powerups.png');
        }

        // Game state
        let player;
        let enemies = [];
        let bullets = [];
        let platforms = [];
        let powerups = [];
        let particles = [];
        let score = 0;
        let currentLevel = START_LEVEL;
        let gameState = 'playing';
        let cameraX = 0;
        let levelWidth = 3200;
        let spawnTimer = 0;
        let gameTime = 0;
        let highScore = parseInt(localStorage.getItem('glideWarriorScore') || '0');
        
        function setup() {
            createCanvas(800, 600);
            imageMode(CENTER);
            initLevel(currentLevel);
        }
        
        function initLevel(level) {
            enemies = [];
            bullets = [];
            powerups = [];
            particles = [];
            gameTime = 0;
            
            player = {
                x: 150, y: 300, w: 48, h: 64,
                vx: 0, vy: 0,
                speed: charStats.speed,
                jumpPower: -charStats.jumpPower,
                gravity: 0.6,
                onGround: false,
                health: charStats.health,
                maxHealth: charStats.health,
                invincible: 0,
                shootCooldown: 0,
                weapon: 'PISTOL',
                jumpsLeft: 1,
                dashCooldown: 0,
                dashing: false,
                dashTimer: 0,
                special: charStats.special,
                spriteIndex: charStats.spriteIndex,
                animFrame: 0,
                facing: 1 // 1 for right, -1 for left
            };
            
            platforms = [];
            generatePlatforms(level);
        }

        function generatePlatforms(level) {
            platforms.push({ x: 0, y: height - 32, w: levelWidth, h: 64 }); // Ground
            let platformCount = 20 + level * 5;
            for (let i = 1; i < platformCount; i++) {
                platforms.push({
                    x: i * 250 + random(-80, 80),
                    y: height - random([120, 220, 320]),
                    w: random([128, 192, 256]),
                    h: 32
                });
            }
        }
        
        function draw() {
            background(20, 20, 40);
            
            if (gameState === 'playing') {
                updateGame();
            } else {
                showEndScreen();
            }
            
            drawHUD();
        }
        
        function updateGame() {
            gameTime++;
            
            cameraX = lerp(cameraX, player.x - width / 3, 0.1);
            cameraX = constrain(cameraX, 0, levelWidth - width);
            
            push();
            translate(-cameraX, 0);
            
            drawBackground();
            drawPlatforms();
            
            updatePlayer();
            drawPlayer();
            
            spawnEnemies();
            updateEnemies();
            updateBullets();
            updatePowerups();
            updateParticles();
            
            pop();
            
            checkWinOrLose();
        }
        
        function updatePlayer() {
            // Movement
            player.animFrame += 0.2;
            if (keyIsDown(LEFT_ARROW)) {
                player.vx = player.dashing ? -player.speed * 2 : -player.speed;
                player.facing = -1;
            } else if (keyIsDown(RIGHT_ARROW)) {
                player.vx = player.dashing ? player.speed * 2 : player.speed;
                player.facing = 1;
            } else {
                player.vx = 0;
            }
            
            player.x += player.vx;
            player.vy += player.gravity;
            player.y += player.vy;
            player.onGround = false;
            
            // Platform collision
            for (let p of platforms) {
                if (player.x + player.w/2 > p.x && player.x - player.w/2 < p.x + p.w &&
                    player.y + player.h/2 > p.y && player.y + player.h/2 < p.y + p.h + player.vy) {
                    if (player.vy > 0) {
                        player.y = p.y - player.h / 2;
                        player.vy = 0;
                        player.onGround = true;
                        player.jumpsLeft = (player.special === 'doubleJump') ? 2 : 1;
                    }
                }
            }
            
            player.x = constrain(player.x, player.w/2, levelWidth - player.w/2);
            
            // Enemy collision
            if (player.invincible === 0) {
                for (let e of enemies) {
                    if (dist(player.x, player.y, e.x, e.y) < (player.w + e.w) / 2) {
                        takeDamage(1);
                    }
                }
            }
            
            if (player.invincible > 0) player.invincible--;
            if (player.shootCooldown > 0) player.shootCooldown--;
            if (player.dashCooldown > 0) player.dashCooldown--;
            if (player.dashTimer > 0) {
                player.dashTimer--;
                if (player.dashTimer === 0) player.dashing = false;
            }
            
            if (player.y > height + 100) takeDamage(player.health);
        }
        
        function drawPlayer() {
            if (player.health <= 0) return;
            
            push();
            translate(player.x, player.y);
            scale(player.facing, 1);

            if (player.invincible % 10 < 5) {
                let frame;
                if (!player.onGround) {
                    frame = 2; // Jump frame
                } else if (player.vx !== 0) {
                    frame = floor(player.animFrame % 2); // Walk frames
                } else {
                    frame = 0; // Idle frame
                }
                
                // image(img, dx, dy, dWidth, dHeight, sx, sy, [sWidth], [sHeight])
                image(assets.playerSheet, 0, 0, player.w, player.h, frame * 32, player.spriteIndex * 48, 32, 48);
            }
            pop();
            
            fill(255);
            textSize(10);
            textAlign(CENTER);
            text(PLAYER_NAME, player.x, player.y - player.h/2 - 5);
        }

        function spawnEnemies() {
            spawnTimer++;
            if (spawnTimer > settings.spawnRate && enemies.length < settings.enemyCount) {
                let spawnX = cameraX + width + random(100, 300);
                if (spawnX < levelWidth - 200) {
                    let enemyType = random(['ground', 'flying']);
                    let y = height - 64;
                    for(let p of platforms) {
                        if (spawnX > p.x && spawnX < p.x + p.w) {
                           y = p.y - 32;
                           break;
                        }
                    }
                    if(enemyType === 'flying') y = random(150, 350);

                    enemies.push({
                        x: spawnX, y: y, w: 48, h: 48,
                        vx: -settings.enemySpeed, vy: 0,
                        health: settings.enemyHealth, maxHealth: settings.enemyHealth,
                        type: enemyType, baseY: y, animFrame: random(100),
                        spriteIndex: enemyType === 'ground' ? 0 : 1
                    });
                    spawnTimer = 0;
                }
            }
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                e.x += e.vx;
                e.animFrame += 0.15;
                if (e.type === 'flying') e.y = e.baseY + sin(frameCount * 0.05 + e.x * 0.1) * 40;

                drawEnemy(e);
                
                if (e.health <= 0) {
                    score += 100;
                    createParticleEffect(e.x, e.y, 20, 'explosion');
                    if (random() < 0.2) {
                        powerups.push({ x: e.x, y: e.y, w: 32, h: 32, type: random(['weapon', 'health']), timer: 300 });
                    }
                    enemies.splice(i, 1);
                } else if (e.x < cameraX - 100) {
                    enemies.splice(i, 1);
                }
            }
        }

        function drawEnemy(e) {
            push();
            translate(e.x, e.y);
            scale(e.vx > 0 ? 1: -1, 1);
            let frame = floor(e.animFrame % 2);
            image(assets.enemySheet, 0, 0, e.w, e.h, frame * 32, e.spriteIndex * 32, 32, 32);
            pop();

            // Health bar
            fill(50);
            rect(e.x - e.w/2, e.y - e.h/2 - 10, e.w, 5);
            fill(255, 0, 0);
            rect(e.x - e.w/2, e.y - e.h/2 - 10, e.w * (e.health / e.maxHealth), 5);
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                b.x += b.vx;
                
                // Draw bullet as a particle/sprite
                push();
                fill(255, 255, 0); noStroke();
                circle(b.x, b.y, 8);
                pop();

                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (dist(b.x, b.y, enemies[j].x, enemies[j].y) < 24) {
                        enemies[j].health--;
                        createParticleEffect(b.x, b.y, 5, 'hit');
                        hit = true;
                        break;
                    }
                }
                
                if (hit || b.x < cameraX - 50 || b.x > cameraX + width + 50) {
                    bullets.splice(i, 1);
                }
            }
        }

        function updatePowerups() {
            for (let i = powerups.length - 1; i >= 0; i--) {
                let p = powerups[i];
                p.timer--;

                let frame = p.type === 'weapon' ? 0 : 1;
                image(assets.powerups, p.x, p.y, p.w, p.h, frame * 32, 0, 32, 32);

                if (dist(player.x, player.y, p.x, p.y) < 40) {
                    if (p.type === 'health') {
                        player.health = min(player.maxHealth, player.health + 1);
                    } else {
                        score += 50; // Simple score bonus for weapon pickup for now
                    }
                    powerups.splice(i, 1);
                } else if (p.timer <= 0) {
                    powerups.splice(i, 1);
                }
            }
        }
        
        function drawBackground() {
            // Parallax background
            for (let i = -1; i < 3; i++) {
                image(assets.background1, width/2 + i * width - cameraX * 0.25, height/2, width, height);
                image(assets.background2, width/2 + i * width - cameraX * 0.5, height/2, width, height);
            }
        }

        function drawPlatforms() {
            for(let p of platforms) {
                // Draw platforms using tileset
                let tiles = p.w / 64;
                for(let i = 0; i < tiles; i++) {
                     image(assets.tileSet, p.x + i * 64 + 32, p.y + p.h/2, 64, 64);
                }
            }
        }
        
        function drawHUD() {
            fill(0, 0, 0, 150);
            rectMode(CORNER);
            rect(0, 0, width, 50);
            
            fill(255);
            textSize(16);
            textAlign(LEFT, CENTER);
            
            text(`Player: ${PLAYER_NAME}`, 10, 25);
            text(`Score: ${score}`, 300, 25);
            text(`Level: ${currentLevel}`, 450, 25);
            
            // Health bar
            fill(50);
            rect(130, 18, 150, 15);
            fill(0, 255, 0);
            rect(130, 18, 150 * (player.health / player.maxHealth), 15);
        }
        
        function showEndScreen() {
            fill(0, 0, 0, 180);
            rectMode(CORNER);
            rect(0, 0, width, height);
            
            let title = gameState === 'victory' ? 'VICTORY!' : 'GAME OVER';
            let titleColor = gameState === 'victory' ? color(0, 255, 0) : color(255, 0, 0);
            
            fill(titleColor);
            textSize(64);
            textAlign(CENTER, CENTER);
            text(title, width/2, height/2 - 80);
            
            fill(255);
            textSize(24);
            text('Final Score: ' + score, width/2, height/2);
            if (score > highScore) {
                text('New High Score!', width/2, height/2 + 40);
            }
            
            textSize(18);
            text('Press R to restart', width/2, height/2 + 100);
        }
        
        function keyPressed() {
            if ((key === ' ' || keyCode === UP_ARROW) && gameState === 'playing') {
                if (player.jumpsLeft > 0) {
                    player.vy = player.jumpPower;
                    player.jumpsLeft--;
                }
            }
            if ((key === 'x' || key === 'X') && gameState === 'playing') {
                if (player.shootCooldown === 0) {
                    bullets.push({ x: player.x, y: player.y, vx: 12 * player.facing });
                    player.shootCooldown = 20;
                }
            }
             if ((key === 'c' || key === 'C') && player.special === 'dash' && player.dashCooldown === 0) {
                player.dashing = true;
                player.dashTimer = 15;
                player.dashCooldown = 90;
                player.invincible = 15;
            }
            if (key === 'r' || key === 'R') {
                if (gameState !== 'playing') {
                    score = 0;
                    currentLevel = START_LEVEL;
                    gameState = 'playing';
                    initLevel(currentLevel);
                }
            }
        }
        
        function takeDamage(amount) {
            if (player.invincible > 0) return;
            if (player.special === 'armor') amount = max(1, amount - 1);
            player.health -= amount;
            player.invincible = 120;
            createParticleEffect(player.x, player.y, 10, 'hit');
        }

        function createParticleEffect(x, y, count, type) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: random(-4, 4), vy: random(-6, 2),
                    life: 40,
                    type: type
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.3; // gravity
                p.life--;
                
                let frame = p.type === 'explosion' ? 0 : 1;
                let alpha = map(p.life, 0, 40, 0, 255);
                
                push();
                tint(255, alpha);
                image(assets.effects, p.x, p.y, 24, 24, frame * 16, 0, 16, 16);
                pop();
                
                if (p.life <= 0) particles.splice(i, 1);
            }
        }
        
        function checkWinOrLose() {
            if (player.x > levelWidth - 150) {
                gameState = 'victory';
                updateHighScore();
            }
            if (player.health <= 0) {
                gameState = 'gameover';
                updateHighScore();
            }
        }

        function updateHighScore() {
             if (score > highScore) {
                highScore = score;
                localStorage.setItem('glideWarriorScore', highScore.toString());
            }
        }
    </script>
</body>
</html>
